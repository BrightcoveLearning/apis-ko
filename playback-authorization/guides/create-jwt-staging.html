
---
title: '만들기<span translate="No"> JSON 웹 토큰</span> (JWT)'
description: '이 항목에서는 생성하는 방법을 배웁니다. <span translate="No"> JSON 웹 토큰</span> (JWT) Brightcove Playback API와 통신할 때 사용할 수 있습니다. '
parent: Guides 
grandparent: Playback Authorization
layout: staging
---
 <h1>{{ page.title }}</h1>
<script>
  var BCLS = ( 함수(창, 문서) { var newURL = 'https://general.support.brightcove.com/developer/create-jwt-stage.html', message = 'This page has moved to the Integrations site. The new url is: ' + newURL + ' You will be redirected in 5 seconds. Please update your bookmarks.', t; function goToNewURL() { window.location.href = newURL; }문서.쓰기(메시지); t = window.setTimeout(goToNewURL, 5000); })(창, 문서);
</script>

<article class="bcls-article">
  <summary>{{ page.description }}</summary>

  <br>
  <aside class="bcls-aside bcls-aside--tip">이 기능은 재생 권한 부여 서비스의 제한된 가용성 단계에 액세스할 수 있는 특정 고객 집합에서 사용할 수 있습니다.</aside>

  <section class="bcls-section">
<h2 id="Introduction">소개</h2>

<p>비디오 라이브러리에 액세스할 때 추가 수준의 보호를 추가하거나 콘텐츠에 대한 사용자 수준 제한을 적용하려면<span translate="No"> JSON 웹 토큰</span> (JWT) Brightcove Playback API를 호출합니다. 토큰을 생성하려면 다음 단계를 따르세요.</p>
<ol class="bcls-tasklist">
	<li><a href="#Generate_public_private_key_pair">공개-개인 키 쌍 생성</a></li>
  <li>
    <a href="#Register_public_key">Brightcove에 공개 키 등록</a>
  </li>
  <li>
    <a href="#Create_a_JSON_Web_Token">만들기<span translate="No"> JSON 웹 토큰</span></a>
  </li>
  <li>
    <a href="#Test_playback">테스트 재생</a>
  </li>
</ol>


</section>

<section class="bcls-section">
<h2 id="Generate_public_private_key_pair">공개-개인 키 쌍 생성</h2>

<p>게시자는 공개-개인 키 쌍을 생성하고 공개 키를 Brightcove에 제공합니다. 개인 키는 게시자가 토큰에 서명하는 데 사용하며 Brightcove와 공유되지 않습니다.</p>

<p>
  공개-개인 키 쌍을 생성하는 방법에는 여러 가지가 있습니다. 여기 몇 가지 예가 있어요.
</p>
<h3>
  예제 bash 스크립트:
</h3>
<p>
  키 쌍을 생성하는 예제 스크립트:
</p>
<pre class="line-numbers"><code class="language-bash" translate="No">#!/bin/bash
set -euo pipefail

NAME=${1:-}
test -z &quot;${NAME:-}&quot; &amp;&amp; NAME=&quot;brightcove-playback-auth-key-$(date +%s)&quot;
mkdir &quot;$NAME&quot;

PRIVATE_PEM=&quot;./$NAME/private.pem&quot;
PUBLIC_PEM=&quot;./$NAME/public.pem&quot;
PUBLIC_TXT=&quot;./$NAME/public_key.txt&quot;

ssh-keygen -t rsa -b 2048 -m PEM -f &quot;$PRIVATE_PEM&quot; -q -N &quot;&quot;
openssl rsa -in &quot;$PRIVATE_PEM&quot; -pubout -outform PEM -out &quot;$PUBLIC_PEM&quot; 2&gt;/dev/null
openssl rsa -in &quot;$PRIVATE_PEM&quot; -pubout -outform DER | base64 &gt; &quot;$PUBLIC_TXT&quot;

rm &quot;$PRIVATE_PEM&quot;.pub

echo &quot;Public key to saved in $PUBLIC_TXT&quot;
</code></pre>
<p>
  스크립트를 실행합니다.
</p>
<pre><code class="language-bash" translate="No">$ bash keygen.sh
</code></pre>

<details>
<summary>
  <h3 id="Example_using_Go">Go 사용 예</h3>
</summary>
<p>
  Go 프로그래밍 언어를 사용하여 키 쌍을 생성하는 예:
</p>
<aside class="bcls-aside bcls-aside--tip">Go를 처음 사용하는 경우 다음을 참조하십시오. <a href="https://golang.org/"> Go 프로그래밍 언어</a>홈페이지.</aside>
<pre class="line-numbers"><code class="language-bash" translate="No">package main

import (
	&quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/x509&quot;
	&quot;encoding/base64&quot;
	&quot;encoding/pem&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;os&quot;
	&quot;path&quot;
	&quot;strconv&quot;
	&quot;time&quot;
)

func main() {
	var out string

	flag.StringVar(&amp;out, &quot;output-dir&quot;, &quot;&quot;, &quot;Output directory to write files into&quot;)
	flag.Parse()

	if out == &quot;&quot; {
		out = &quot;rsa-key_&quot; + strconv.FormatInt(time.Now().Unix(), 10)
	}

	if err := os.MkdirAll(out, os.ModePerm); err != nil {
		panic(err.Error())
	}

	priv, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		panic(err.Error())
	}

	privBytes := x509.MarshalPKCS1PrivateKey(priv)

	pubBytes, err := x509.MarshalPKIXPublicKey(priv.Public())
	if err != nil {
		panic(err.Error())
	}

	privOut, err := os.OpenFile(path.Join(out, &quot;private.pem&quot;), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		panic(err.Error())
	}

	if err := pem.Encode(privOut, &amp;pem.Block{Type: &quot;RSA PRIVATE KEY&quot;, Bytes: privBytes}); err != nil {
		panic(err.Error())
	}

	pubOut, err := os.OpenFile(path.Join(out, &quot;public.pem&quot;), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		panic(err.Error())
	}

	if err := pem.Encode(pubOut, &amp;pem.Block{Type: &quot;PUBLIC KEY&quot;, Bytes: pubBytes}); err != nil {
		panic(err.Error())
	}

	var pubEnc = base64.StdEncoding.EncodeToString(pubBytes)

	var pubEncOut = path.Join(out, &quot;public_key.txt&quot;)
	if err := ioutil.WriteFile(pubEncOut, []byte(pubEnc+&quot;\n&quot;), 0600); err != nil {
		panic(err.Error())
	}

	fmt.Println(&quot;Public key saved in &quot; + pubEncOut)
}
</code></pre>
</details>

<details>
&lt;<summary>
  <h3 id="Example_using_node_js">node.js 사용 예</h3>
</summary>
<p>
  node.js를 사용하여 키 쌍을 생성하는 예:
</p>
<aside class="bcls-aside bcls-aside--tip">이 스크립트 예제에는 노드 버전 11 이상이 필요합니다.</aside>
<pre class="line-numbers"><code class="language-javascript" translate="No">var crypto = require(&quot;crypto&quot;);
var fs = require(&quot;fs&quot;);

var now = Math.floor(new Date() / 1000);
var dir = &quot;rsa-key_&quot; + now;
fs.mkdirSync(dir);

crypto.generateKeyPair(
  &quot;rsa&quot;,
  {modulusLength: 2048},
  (err, publicKey, privateKey) =&gt; {
    fs.writeFile(
      dir + &quot;/public.pem&quot;,
      publicKey.export({ type: &quot;spki&quot;, format: &quot;pem&quot; }),
      err =&gt; {}
    );
    fs.writeFile(
      dir + &quot;/public_key.txt&quot;,
      publicKey.export({ type: &quot;spki&quot;, format: &quot;der&quot; }).toString(&quot;base64&quot;) +
        &quot;\n&quot;,
      err =&gt; {}
    );
    fs.writeFile(
      dir + &quot;/private.pem&quot;,
      privateKey.export({ type: &quot;pkcs1&quot;, format: &quot;pem&quot; }),
      err =&gt; {}
    );
  }
);

console.log(&quot;Public key saved in &quot; + dir + &quot;/public_key.txt&quot;);</code></pre>

</details>

</section>

<section class="bcls-section">
<h2 id="Register_public_key">공개 키 등록</h2>

<p>Key API를 사용하여 Brightcove에 공개 키를 등록합니다.</p>
<h3>키 API</h3>
<p>
  Key API는 Brightcove로 공개 키를 관리하는 데 사용됩니다.
</p>
<aside class="bcls-aside bcls-aside--tip">
  <p>
    DRM을 관리할 때 다음을 사용할 수도 있습니다. <a href="/playback-authorization/guides/additional-apis-for-pas.html">재생 승인 서비스를 위한 추가 API</a> .
  </p>
</aside>


<h3>기본 URL</h3>
<p>
  API의 기본 URL은 다음과 같습니다.
</p>
<pre><code class="language-http" translate="No">https://playback-auth.api.brightcove.com</code></pre>

<h3>계정 경로</h3>
<p>
  모든 경우에 특정 Video Cloud 계정에 대한 요청이 이루어집니다. 따라서 기본 URL에 항상 계정이라는 용어와 계정 ID를 추가합니다.
</p>
<pre><code class="language-http" translate="No">https://playback-auth.api.brightcove.com/v1/accounts/{accountID}</code></pre>

<h3>권한 부여</h3>
<p>
  요청에 대한 액세스 토큰이 필요하며 Authorization 헤더에 있어야 합니다.
</p>
<pre><code class="language-http" translate="No">Authorization: Bearer {access_token}</code></pre>
<p>
  액세스 토큰은 Brightcove OAuth 서비스에서 가져와야 하는 임시 OAuth2 액세스 토큰입니다. 클라이언트 자격 증명을 얻고 이를 사용하여 액세스 토큰을 검색하는 방법에 대한 자세한 내용은 다음을 참조하십시오. <a href="https://support.brightcove.com/overview-oauth-api-v4">브라이트코브 OAuth 개요</a> .
</p>

<h3>권한</h3>
<p>
  Key API에 대한 요청은 다음에서 이루어져야 합니다. <a href="https://support.brightcove.com/oauth-api">클라이언트 자격 증명</a>다음 권한으로:
</p>
<ul>
  <li>
    <code translate="No">video-cloud/playback-auth/key/read</code>
  </li>
  <li>
    <code translate="No">video-cloud/playback-auth/key/write</code>
  </li>
</ul>

<h3>키 관리</h3>
<p>
  Key API는 다음 요청을 지원합니다.
</p>
<aside class="bcls-aside bcls-aside--information">
  <p>
    노트:
  </p>
  <ul>
    <li>
      기존 키는 편집할 수 없지만 삭제하고 새 키는 만들 수 있습니다.
    </li>
    <li>
      키 순환을 지원하기 위해 한 번에 최대 3개의 키를 등록할 수 있으며 키를 삭제할 수 있습니다. 실제로는 1개의 키만 있는 것이 가장 좋습니다.
    </li>
  </ul>
</aside>

<h4>새 키 등록:</h4>
<p>
  API 요청 본문에 공개 키 값을 입력합니다. 에서 키를 찾을 수 있습니다. <strong> public_key.txt</strong>파일.
</p>
<h5>요구</h5>
<pre class="line-numbers"><code class="language-http" translate="No">POST /v1/accounts/{accountID}/keys
    Content-Type: application/json
    Body: {&quot;value&quot;: &quot;MFkwEwYHKoZIzj0CAQYIKoZIzj...MyeQviqploA==&quot;}
</code></pre>
<details>
<summary>
  <p id="Using_Curl">컬 사용하기</p>
</summary>
  <pre class="line-numbers"><code class="language-curl">curl -X POST \\ -H "콘텐츠 유형: 응용 프로그램/json" \\ -H "권한: 교군꾼{access_token} " \\ -NS ' {"value": "{your_public_key_value} "}'  \\ https://playback-auth.api.brightcove.com/v1/accounts/ {accountID} /키</code></pre>
<h5>응답</h5>
<pre class="line-numbers"><code class="language-json" translate="No">{
  &quot;id&quot;: &quot;{your_public_key_id}&quot;,
  &quot;type&quot;: &quot;public&quot;,
  &quot;algorithm&quot;: &quot;rsa&quot;,
  &quot;value&quot;: &quot;{your_public_key_value}&quot;,
  &quot;createdAt&quot;: &quot;2020-01-03T20:30:36.488Z&quot;
}</code></pre>
</details>


<h4>목록 키:</h4>
<p>
  계정의 공개 키 목록을 가져옵니다.
</p>
<pre><code class="language-http" translate="No">GET /v1/accounts/{accountID}/keys</code></pre>

<h4>하나의 키 가져오기:</h4>
<p>
  계정의 공개 키에 대한 세부 정보를 가져옵니다.
</p>
<pre><code class="language-http" translate="No">GET /v1/accounts/{accountID}/keys/{key_Id}</code></pre>

<h4>하나의 키 삭제:</h4>
<p>
  계정에서 공개 키를 삭제합니다.
</p>
<pre><code class="language-http" translate="No">DELETE /v1/accounts/{accountID}/keys/{key_Id}</code></pre>

</section>

<section class="bcls-section">
<h2 id="Create_a_JSON_Web_Token">만들기<span translate="No"> JSON 웹 토큰</span></h2>

<p>게시자는<a href="https://jwt.io/introduction/"> JSON 웹 토큰</a> (JWT). 토큰은 SHA-256 해시 알고리즘(JWT 사양에서 " <a href="https://ldapwiki.com/wiki/RS256"> RS256</a> ") 다른 JWT 알고리즘은 지원되지 않습니다.</p>
<p>
  표준의 하위 집합<a href="https://auth0.com/docs/tokens/jwt-claims"> JSON 웹 토큰 클레임</a> Brightcove에서 정의한 일부 개인 청구와 함께 사용됩니다. 당신은 만들 것입니다<span translate="No"> JSON 웹 토큰</span>개인 키로 서명했습니다.
</p>

<h3>정적 URL 전달에 대한 클레임</h3>
<p>
  사용할 수 있는 클레임 목록은 다음을 참조하세요. <a href="node/18961/">정적 URL 전달</a>문서.
</p>

<h3>재생 승인 요청</h3>
<p>
  다음 주장은 다음과 함께 사용할 수 있습니다. <a href="/playback-authorization/getting-started/overview-playback-authorization-service.html"> Brightcove의 재생 인증 서비스</a> .
</p>

<table class="bcls-table">
      <thead class="bcls-table__head">
        <tr>
          <th>들</th>
          <th>유형</th>
          <th>필수의</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody class="bcls-table__body">
        <tr>
          <td><code translate="No">accid</code></td>
          <td>끈</td>
          <td>예</td>
          <td>재생 중인 콘텐츠를 소유한 계정 ID</td>
        </tr>
        <tr>
          <td><code translate="No">exp</code></td>
          <td>정수</td>
          <td>예</td>
          <td>Epoch 이후 이 토큰이 더 이상 유효하지 않은 시간(초)입니다. 부터 30일 이내여야 합니다. <code translate="No">iat</code></td>
        </tr>
        <tr>
          <td><code translate="No">iat</code></td>
          <td>정수</td>
          <td>예</td>
          <td>이 토큰이 발행된 시간(Epoch 이후 초)</td>
        </tr>
        <tr>
          <td><code translate="No">conid</code></td>
          <td>끈</td>
          <td></td>
          <td>있는 경우 이 토큰은 특정 Video Cloud 비디오 ID에 대한 라이선스 가져오기만 승인합니다.
            <br /><br />
            유효한 동영상 ID여야 합니다.
          </td>
        </tr>
        <!-- <tr> This is internal use only!!
          <td><code translate="No">crt </code></td>
          <td>String</td>
          <td></td>
          <td>Customer Rights Token used for DRM rights management (DRM Only).
          </td>
        </tr> -->
        <tr>
          <td><code translate="No">maxip</code></td>
          <td>정수</td>
          <td></td>
          <td>존재하는 경우 이 토큰은 이렇게 다양한 IP 주소에서만 사용할 수 있습니다. (DRM 및 AES-128)
            <br /><br />
            세션 추적에 필요합니다.
          </td>
        </tr>
        <tr>
          <td><code translate="No">maxu</code></td>
          <td>정수</td>
          <td></td>
          <td>
              있는 경우 이 토큰은 이 많은 라이선스 요청에 대해서만 유효합니다. (DRM 및 AES-128)
            <br><br>
            <ul>
              <li>
                HLSe의 경우 플레이어는 비디오를 재생할 때 일반적으로 변환당 하나씩 여러 요청을 합니다. NS <code translate="No">maxu</code>이러한 추가 요청을 처리할 수 있을 만큼 충분히 높게 설정되어야 합니다.
              </li>
              <li>
                DRM의 경우 재생당 하나의 라이선스 요청이 이루어집니다.
              </li>
            </ul>
              세션 추적에 필요합니다.
          </td>
        </tr>
        <tr>
          <td><code translate="No">ua</code></td>
          <td>끈</td>
          <td></td>
          <td>존재하는 경우 이 토큰은 이 사용자 에이전트의 요청에 대해서만 유효합니다.
            <br /><br />
            이 필드는 검증되지 않았습니다.
          </td>
        </tr>
      </tbody>
    </table>

    <h3>재생권 주장</h3>
    <p>
      다음 주장은 다음과 함께 사용할 수 있습니다. <a href="/playback-rights/getting-started/overview-epa.html"> Brightcove의 재생 권한 관리 서비스</a> .
    </p>
    <aside class="bcls-aside bcls-aside--information">DRM과 함께 재생 권한을 사용하는 경우 AES-128을 사용할 수 없습니다.</aside>

    <table class="bcls-table">
          <thead class="bcls-table__head">
            <tr>
              <th>들</th>
              <th>유형</th>
              <th>필수의</th>
              <th>동시 스트림 제한에 필요</th>
              <th>DRM만</th>
              <th>설명</th>
            </tr>
          </thead>
          <tbody class="bcls-table__body">
            <tr>
              <td><code translate="No">accid</code></td>
              <td>끈</td>
              <td>예</td>
              <td></td>
              <td></td>
              <td>재생 중인 콘텐츠를 소유한 계정 ID</td>
            </tr>
            <tr>
              <td><code translate="No">exp</code></td>
              <td>정수</td>
              <td>예</td>
              <td></td>
              <td></td>
              <td>Epoch 이후 이 토큰이 더 이상 유효하지 않은 시간(초)입니다. 부터 30일 이내여야 합니다. <code translate="No">iat</code></td>
            </tr>
            <tr>
              <td><code translate="No">iat</code></td>
              <td>정수</td>
              <td>예</td>
              <td></td>
              <td></td>
              <td>이 토큰이 발행된 시간(Epoch 이후 초)</td>
            </tr>
            <tr>
              <td><code translate="No">nbf</code></td>
              <td>정수</td>
              <td></td>
              <td></td>
              <td></td>
              <td>이 토큰이 유효하기 시작하는 시간(Epoch 이후 초 단위)</td>
            </tr>
            <tr>
              <td><code translate="No">pkid</code></td>
              <td>끈</td>
              <td></td>
              <td></td>
              <td></td>
              <td>이 토큰을 확인하는 데 사용되는 공개 키 ID입니다. Brightcove의 Playback Authorization Service에 등록되어 있으며 RSA 키 형식을 사용해야 합니다.
                <br /><br />
                만약에<code translate="No">pkid</code>지정되면 지정된 키로 토큰의 유효성을 검사합니다.
                <br /><br />
                그렇지 않은 경우<code translate="No">pkid</code>지정되면 계정에 대한 모든 키를 검색하고 모든 키에 대해 유효성을 검사합니다.
              </td>
            </tr>
            <tr>
              <td><code translate="No">prid</code></td>
              <td>끈</td>
              <td></td>
              <td></td>
              <td></td>
              <td>NS <code translate="No">playback_rights_id</code> . 이 비디오의 카탈로그에 설정된 ID를 재정의하는 데 사용됩니다.
                <br /><br />
                이 필드는 검증되지 않았습니다.
              </td>
            </tr>
            <tr>
              <td><code translate="No">tags</code></td>
              <td>배열 &lt;문자열&gt;</td>
              <td></td>
              <td></td>
              <td></td>
              <td>존재하는 경우 이 토큰은 재생 권한이 부여된 나열된 태그에 대해서만 유효합니다.</td>
            </tr>
            <tr>
              <td><code translate="No">vids</code></td>
              <td>배열 &lt;문자열&gt;</td>
              <td></td>
              <td></td>
              <td></td>
              <td>있는 경우 이 토큰은 비디오 ID 집합에 대한 라이선스 가져오기만 승인합니다.</td>
            </tr>
             <tr>
              <td><code translate="No">cbeh</code></td>
              <td>끈</td>
              <td></td>
              <td></td>
              <td>예</td>
              <td>값을 다음으로 설정<code translate="No">BLOCK_NEW</code>최대 스트림 수에 도달하면 동일한 사용자의 새 요청을 차단하는 동시 스트림 제한을 활성화합니다.
                <br /><br />
                값을 다음으로 설정<code translate="No">BLOCK_NEW_USER</code>최대 스트림 수에 도달한 경우에만 새 사용자의 새 요청을 차단합니다.
                <br /><br />
                기본값은 최대 스트림 수에 도달하면 가장 오래된 스트림을 차단합니다.
                <br /><br />
          동시 스트림 제한: 선택 과목
              </td>
            </tr>
            <tr>
              <td><code translate="No">cexp</code></td>
              <td>끈</td>
              <td></td>
              <td></td>
              <td>예</td>
              <td>세션의 동시 만료 - 기본적으로 콘텐츠 지속 시간의 2배 또는 15분 중 더 긴 시간으로 설정됩니다.
                <br /><br />
                이것은 세션이 유효한 기간을 정의하며 그 시간이 지나면 최종 뷰어가 재생을 계속하기 위해 새 세션을 시작해야 합니다. 예시: <code translate="No">2h</code>또는<code translate="No">42m</code>
                <br /><br />
          동시 스트림 제한: 선택 과목
              </td>
            </tr>
            <tr>
              <td><code translate="No">climit</code></td>
              <td>정수</td>
              <td></td>
              <td>예</td>
              <td>예</td>
              <td>이 필드가 포함되면 라이선스 갱신 요청과 함께 동시 스트림 제한이 활성화됩니다. 이 값은 허용되는 동시 감시자의 수를 나타냅니다.
                <br /><br />
          동시 스트림 제한: 필수의
        </td>
            </tr>
            <tr>
              <td><code translate="No">dlimit</code></td>
              <td>정수</td>
              <td></td>
              <td></td>
              <td>예</td>
              <td>이 필드가 포함되면 지정된 사용자( <code translate="No">uid</code> ). 값은 &gt;이어야 합니다. <code translate="No">0</code> .
                <br /><br />
                이전에 허용된 장치는 다음과 같은 경우 계속 작동합니다. <code translate="No">dlimit</code>값은 이후 요청에서 삭제됩니다.
                <br /><br />
                예: 값이 다음으로 설정된 경우<code translate="No">3</code> , 사용자는 장치 A, B 및 C에서 재생할 수 있습니다(모두 허용됨). 장치 D에서 재생을 시도하면 거부됩니다.
                <br /><br />
                값이 다음으로 변경되면<code translate="No">1</code> , 사용자는 3개의 장치 A, B, C 모두에서 계속 플레이할 수 있습니다. 단, <a href="/playback-rights/references/reference.html#operation/GetDevices">기기 API</a> .
                <br /><br />
            장치 등록: 필수의
              </td>
            </tr>
            <tr>
              <td><code translate="No">sid</code></td>
              <td>끈</td>
              <td></td>
              <td></td>
              <td>예</td>
              <td>현재 스트림의 세션 ID를 지정하면 세션이 정의되는 방식을 제어할 수 있습니다. 기본적으로 세션은 User-Agent(브라우저) + IP 주소 + 비디오 ID로 정의됩니다.
                <br /><br />
                  예를 들어 세션의 정의를 IP 주소 + 비디오 ID로 느슨하게 할 수 있습니다.
                  <br /><br />
            동시 스트림 제한: 선택 과목
              </td>
            </tr>
            <tr>
              <td><code translate="No">uid</code></td>
              <td>끈</td>
              <td></td>
              <td></td>
              <td>예</td>
              <td>최종 뷰어의 사용자 ID입니다. 이 필드는 동시 스트림 제한을 적용하기 위해 여러 세션의 상관 관계를 지정하는 데 사용됩니다.
                <br /><br />
            장치 등록: 필수의
              </td>
            </tr>
          </tbody>
        </table>

<h3>토큰 생성</h3>
<p>
  라이브러리는 일반적으로 JWT 토큰을 생성하는 데 사용할 수 있습니다. 자세한 내용은<a href="https://jwt.io/"> JSON 웹 토큰</a>대지.
</p>
<h4>
  예제 bash 스크립트:
</h4>
<p>
  JWT 토큰을 생성하는 스크립트 예:
</p>
<pre class="line-numbers"><code class="language-bash" translate="No">#! /usr/bin/env bash
# Static header fields.
HEADER='{
	&quot;type&quot;: &quot;JWT&quot;,
	&quot;alg&quot;: &quot;RS256&quot;
}'

payload='{
	&quot;pkid&quot;: &quot;{your_public_key_id}&quot;,
	&quot;accid&quot;: &quot;{your_account_id}&quot;
}'

# Use jq to set the dynamic `iat` and `exp`
# fields on the payload using the current time.
# `iat` is set to now, and `exp` is now + 1 second.
PAYLOAD=$(
	echo &quot;${payload}&quot; | jq --arg time_str &quot;$(date +%s)&quot; \
	'
	($time_str | tonumber) as $time_num
	| .iat=$time_num
	| .exp=($time_num + 60 * 60)
	'
)

function b64enc() { openssl enc -base64 -A | tr '+/' '-_' | tr -d '='; }

function rs_sign() { openssl dgst -binary -sha256 -sign playback-auth-keys/private.pem ; }

JWT_HDR_B64=&quot;$(echo -n &quot;$HEADER&quot; | b64enc)&quot;
JWT_PAY_B64=&quot;$(echo -n &quot;$PAYLOAD&quot; | b64enc)&quot;
UNSIGNED_JWT=&quot;$JWT_HDR_B64.$JWT_PAY_B64&quot;
SIGNATURE=$(echo -n &quot;$UNSIGNED_JWT&quot; | rs_sign | b64enc)

echo &quot;$UNSIGNED_JWT.$SIGNATURE&quot;
</code></pre>
<p>
  스크립트를 실행합니다.
</p>
<pre><code class="language-bash" translate="No">$ bash jwtgen.sh
</code></pre>
<p>

</p>
<details>
<summary>
  <h4 id="Example_using_Go_token">Go 사용 예</h4>
</summary>
<p>
  다음은 타사 라이브러리를 사용하지 않고 토큰을 생성하기 위한 참조 Go 구현(cli 도구)의 예입니다.
</p>
<aside class="bcls-aside bcls-aside--tip">Go를 처음 사용하는 경우 다음을 참조하십시오. <a href="https://golang.org/"> Go 프로그래밍 언어</a>홈페이지.</aside>
<pre class="line-numbers"><code class="language-bash" translate="No">package main

import (
	&quot;crypto&quot;
	&quot;crypto/ecdsa&quot;
	&quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/sha256&quot;
	&quot;crypto/x509&quot;
	&quot;encoding/base64&quot;
	&quot;encoding/json&quot;
	&quot;encoding/pem&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;os&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

// Header is the base64UrlEncoded string of a JWT header for the RS256 algorithm
const RSAHeader = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9&quot;

// Header is the base64UrlEncoded string of a JWT header for the EC256 algorithm
const ECHeader = &quot;eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9&quot;

// Claims represents constraints that should be applied to the use of the token
type Claims struct {
	Iat   float64 `json:&quot;iat,omitempty&quot;`   // Issued At
	Exp   float64 `json:&quot;exp,omitempty&quot;`   // Expires At
	Accid string  `json:&quot;accid,omitempty&quot;` // Account ID
	Conid string  `json:&quot;conid,omitempty&quot;` // Content ID
	Maxu  float64 `json:&quot;maxu,omitempty&quot;`  // Max Uses
	Maxip float64 `json:&quot;maxip,omitempty&quot;` // Max IPs
	Ua    string  `json:&quot;ua,omitempty&quot;`    // User Agent
}

func main() {
	var key, algorithm string

	c := Claims{Iat: float64(time.Now().Unix())}

	flag.StringVar(&amp;key, &quot;key&quot;, &quot;&quot;, &quot;Path to private.pem key file&quot;)
	flag.StringVar(&amp;c.Accid, &quot;account-id&quot;, &quot;&quot;, &quot;Account ID&quot;)
	flag.StringVar(&amp;c.Conid, &quot;content-id&quot;, &quot;&quot;, &quot;Content ID (eg, video_id or live_job_id)&quot;)
	flag.Float64Var(&amp;c.Exp, &quot;expires-at&quot;, float64(time.Now().AddDate(0, 0, 1).Unix()), &quot;Epoch timestamp (in seconds) for when the token should stop working&quot;)
	flag.Float64Var(&amp;c.Maxu, &quot;max-uses&quot;, 0, &quot;Maximum number of times the token is valid for&quot;)
	flag.Float64Var(&amp;c.Maxip, &quot;max-ips&quot;, 0, &quot;Maximum number of unique IP addresses the token is valid for&quot;)
	flag.StringVar(&amp;c.Ua, &quot;user-agent&quot;, &quot;&quot;, &quot;User Agent that the token is valid for&quot;)
	flag.StringVar(&amp;algorithm, &quot;algo&quot;, &quot;&quot;, &quot;Key algorithm to use for signing. Valid: ec256, rsa256&quot;)
	flag.Parse()

	if key == &quot;&quot; {
		fmt.Printf(&quot;missing required flag: -key\n\n&quot;)
		flag.Usage()
		os.Exit(1)
	}

	if algorithm == &quot;&quot; {
		fmt.Printf(&quot;missing required flag: -algo\n\n&quot;)
		flag.Usage()
		os.Exit(2)
	}

	if algorithm != &quot;rsa256&quot; &amp;&amp; algorithm != &quot;ec256&quot; {
		fmt.Printf(&quot;missing valid value for -algo flag. Valid: rsa256, ec256\n\n&quot;)
		flag.Usage()
		os.Exit(3)
	}

	if c.Accid == &quot;&quot; {
		fmt.Printf(&quot;missing required flag: -account-id\n\n&quot;)
		flag.Usage()
		os.Exit(4)
	}

	bs, err := json.Marshal(c)
	if err != nil {
		fmt.Println(&quot;failed to marshal token to json&quot;, err)
		os.Exit(5)
	}

	kbs, err := ioutil.ReadFile(key)
	if err != nil {
		fmt.Println(&quot;failed to read private key&quot;, err)
		os.Exit(6)
	}

	if algorithm == &quot;rsa256&quot; {
		processRSA256(kbs, bs)
	} else {
		processEC256(kbs, bs)
	}
}

func processRSA256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(7)
	}

	if block.Type != &quot;RSA PRIVATE KEY&quot; {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(8)
	}

	pKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
	if err != nil {
		fmt.Println(&quot;failed to parse rsa private key&quot;, err)
		os.Exit(9)
	}

	message := RSAHeader + &quot;.&quot; + base64.RawURLEncoding.EncodeToString(bs)

	hash := crypto.SHA256
	hasher := hash.New()
	_, _ = hasher.Write([]byte(message))
	hashed := hasher.Sum(nil)

	r, err := rsa.SignPKCS1v15(rand.Reader, pKey, hash, hashed)
	if err != nil {
		fmt.Println(&quot;failed to sign token&quot;, err)
		os.Exit(10)
	}

	sig := strings.TrimRight(base64.RawURLEncoding.EncodeToString(r), &quot;=&quot;)

	fmt.Println(message + &quot;.&quot; + sig)
}

func processEC256(kbs, bs []byte) {
	block, _ := pem.Decode(kbs)
	if block == nil {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(7)
	}

	if block.Type != &quot;EC PRIVATE KEY&quot; {
		fmt.Println(&quot;failed to decode PEM block containing private key&quot;)
		os.Exit(8)
	}

	pkey, err := x509.ParseECPrivateKey(block.Bytes)
	if err != nil {
		fmt.Println(&quot;failed to parse ec private key&quot;, err)
		os.Exit(9)
	}

	message := ECHeader + &quot;.&quot; + base64.RawURLEncoding.EncodeToString(bs)
	hash := sha256.Sum256([]byte(message))

	r, s, err := ecdsa.Sign(rand.Reader, pkey, hash[:])
	if err != nil {
		fmt.Println(&quot;failed to sign token&quot;, err)
		os.Exit(10)
	}

	curveBits := pkey.Curve.Params().BitSize

	keyBytes := curveBits / 8
	if curveBits%8 &gt; 0 {
		keyBytes++
	}

	rBytes := r.Bytes()
	rBytesPadded := make([]byte, keyBytes)
	copy(rBytesPadded[keyBytes-len(rBytes):], rBytes)

	sBytes := s.Bytes()
	sBytesPadded := make([]byte, keyBytes)
	copy(sBytesPadded[keyBytes-len(sBytes):], sBytes)

	out := append(rBytesPadded, sBytesPadded...)

	sig := base64.RawURLEncoding.EncodeToString(out)
	fmt.Println(message + &quot;.&quot; + sig)
}
</code></pre>
</details>

<h4>결과</h4>
<p>
  다음은 다음을 사용하여 디코딩된 토큰의 예입니다. <a href="https://jwt.io/"> https://JWT.io</a>전체 청구 세트 지정:
</p>
<p>
  헤더:
</p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  &quot;alg&quot;: &quot;RS256&quot;,
  &quot;type&quot;: &quot;JWT&quot;
}
</code></pre>

<p>
  유효 탑재량:
</p>
<pre class="line-numbers"><code class="language-json" translate="No">{
  &quot;accid&quot;: &quot;1100863500123&quot;,
  &quot;conid&quot;: &quot;51141412620123&quot;,
  &quot;exp&quot;: 1554200832,
  &quot;iat&quot;: 1554199032,
  &quot;maxip&quot;: 10,
  &quot;maxu&quot;: 10,
  &quot;ua&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36&quot;
}
</code></pre>
</section>

<section class="bcls-section">
<h2 id="Test_playback">테스트 재생</h2>

<p>필수는 아니지만 플레이어를 구성하기 전에 비디오 재생을 테스트할 수 있습니다.</p>
<p>
  재생 요청:
</p>
<pre class="line-numbers"><code class="language-http" translate="No">curl -X GET \
 -H 'Authorization: Bearer {JWT}' \
 https://edge-auth.api.brightcove.com/playback/v1/accounts/{your_account_id}/videos/{your_video_id}
</code></pre>
</section>

</article>